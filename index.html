<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>spoodblort bookie tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="./cors.js"></script>
    <script src="./localstorage.js"></script>
    <style>
        body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 min-h-screen">
    <header class="border-b border-gray-800 bg-gray-900/80 backdrop-blur sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
            <h1 class="text-xl font-bold">spoodblort bookie tools</h1>
            <nav class="flex items-center gap-2">
                <button data-route="today" class="nav-btn px-3 py-2 rounded-md text-sm font-semibold hover:bg-gray-800" aria-current="page">today's matchups</button>
                <button data-route="fights" class="nav-btn px-3 py-2 rounded-md text-sm font-semibold hover:bg-gray-800">fights</button>
                <button data-route="fighters" class="nav-btn px-3 py-2 rounded-md text-sm font-semibold hover:bg-gray-800">fighters</button>
            </nav>
        </div>
    </header>

    <main id="app" class="max-w-7xl mx-auto px-4 py-6">
        <div id="status" class="text-sm text-gray-400"></div>
        <div id="view" class="mt-4"></div>
        </main>

    <template id="table-template">
        <div class="overflow-auto rounded-lg border border-gray-800">
            <table class="min-w-full text-left text-sm">
                <thead class="bg-gray-900/70 text-gray-300 sticky top-0">
                    <tr id="thead-row"></tr>
                </thead>
                <tbody id="tbody" class="divide-y divide-gray-800 bg-gray-900/40"></tbody>
            </table>
    </div>
    </template>

    <script>
        const $ = (sel, el = document) => el.querySelector(sel);
        const $$ = (sel, el = document) => Array.from(el.querySelectorAll(sel));
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        const ROUTES = {
            today: 'today',
            fights: 'fights',
            fighters: 'fighters',
        };

        async function fetchJson(url) {
            const start = performance.now();
            let res;
            try {
                res = await fetch(url);
            } catch (e) {
                return { ok: false, status: 0, data: null, error: e?.message || 'network error', ms: performance.now() - start };
            }
            const ms = performance.now() - start;
            if (!res.ok) {
                let errText = '';
                try { errText = await res.text(); } catch {}
                return { ok: false, status: res.status, data: null, error: errText || `http ${res.status}` , ms };
            }
            try {
                const data = await res.json();
                return { ok: true, status: res.status, data, error: null, ms };
            } catch (e) {
                return { ok: false, status: res.status, data: null, error: 'invalid json', ms };
            }
        }

        // Spinner status for CORS proxy attempts
        function setStatusSpinner(attempt, total, proxyName) {
            const el = $('#status');
            el.innerHTML = `
                <span class="inline-block w-3 h-3 mr-2 border-2 border-gray-400 border-t-transparent rounded-full align-[-2px] animate-spin"></span>
                trying CORS proxy ${attempt} of ${total}${proxyName ? ` (${proxyName})` : ''}...
            `;
        }

        // Fetch JSON via CORS proxies with live attempt updates
        async function fetchJsonViaCors(url) {
            const start = performance.now();
            try {
                const { data, response, proxy } = await window.cors.fetchJson(url, undefined, (i, n, p) => setStatusSpinner(i, n, p?.name));
                return { ok: true, status: response.status, data, error: null, ms: performance.now() - start, proxy: proxy?.name };
            } catch (e) {
                return { ok: false, status: 0, data: null, error: e?.message || 'all proxies failed', ms: performance.now() - start };
            }
        }

        function setStatus(message) {
            const el = $('#status');
            el.textContent = message || '';
        }

        function setView(node) {
            const view = $('#view');
            view.innerHTML = '';
            if (node) view.appendChild(node);
        }

        function renderTable(headers, rows) {
            const tpl = $('#table-template');
            const root = tpl.content.cloneNode(true);
            const theadRow = $('#thead-row', root);
            const tbody = $('#tbody', root);
            headers.forEach(h => {
                const th = document.createElement('th');
                th.className = 'px-3 py-2 font-semibold';
                th.textContent = h;
                theadRow.appendChild(th);
            });
            rows.forEach(r => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-800/50';
                r.forEach(cell => {
                    const td = document.createElement('td');
                    td.className = 'px-3 py-2 align-top text-gray-200';
                    if (cell instanceof Node) td.appendChild(cell); else td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            const container = document.createElement('div');
            container.appendChild(root);
            return container;
        }

        function formatTime(s) {
            if (!s) return '';
            try { return new Date(s).toLocaleString(); } catch { return s; }
        }

        // Fighters cache for ID->Name mapping across views
        const fightersCache = {
            loaded: false,
            byId: new Map(),
            raw: [],
        };

        function ensureFightersCacheFromStore() {
            if (fightersCache.loaded) return fightersCache;
            const cached = window.store.getJSON('fighters');
            if (Array.isArray(cached)) {
                fightersCache.raw = cached;
                cached.forEach(f => fightersCache.byId.set(f.ID, f));
                fightersCache.loaded = true;
            }
            return fightersCache;
        }

        async function routeToday() {
            setStatus("rendering today's schedule from cache...");
            const data = window.store.getJSON('schedule_today');
            if (!data) {
                setView(renderTable(['info'], [["no cached schedule yet"]]));
                setStatus('');
                return;
            }

            const { meta, fights = [], error } = data || {};
            // On Sundays this will be empty per spec
            if (error) {
                setStatus(`warning: ${error}`);
            } else {
                setStatus('');
            }

            // Ensure we can map fighter names if any IDs are present
            if (fights.length > 0) {
                ensureFightersCacheFromStore();
            }

            const headers = ['ID', 'Tournament', 'Fighter 1', 'Fighter 2', 'Scheduled', 'Status', 'Winner', 'Final Scores'];
            const rows = fights.map(f => {
                const f1Name = f.fighter1_name || fightersCache.byId.get(f.fighter1_id)?.Name || String(f.fighter1_id || '');
                const f2Name = f.fighter2_name || fightersCache.byId.get(f.fighter2_id)?.Name || String(f.fighter2_id || '');
                const winner = f.winner_id ? (fightersCache.byId.get(f.winner_id)?.Name || f.winner_id) : '';
                const final = (f.final_score1 != null && f.final_score2 != null) ? `${f.final_score1} - ${f.final_score2}` : '';
                return [
                    String(f.id),
                    f.tournament_id != null ? String(f.tournament_id) : '',
                    f1Name,
                    f2Name,
                    formatTime(f.scheduled_time),
                    f.status || '',
                    winner,
                    final,
                ];
            });

            const metaBlock = document.createElement('div');
            metaBlock.className = 'mb-3 text-sm text-gray-400';
            if (meta) {
                metaBlock.textContent = `day ${meta.day || ''} (${meta.timezone || ''}) • now ${meta.now || ''}${meta.tournament_id ? ` • tournament ${meta.tournament_id}` : ''}`;
            }

            const table = renderTable(headers, rows.length ? rows : [["no fights scheduled today"]]);
            const container = document.createElement('div');
            container.appendChild(metaBlock);
            container.appendChild(table);
            setView(container);
            setStatus('');
        }

        function unwrapNullish(obj, key) {
            const v = obj?.[key];
            if (v && typeof v === 'object' && 'Valid' in v) {
                return v.Valid ? (('Int64' in v) ? v.Int64 : (('String' in v) ? v.String : (('Time' in v) ? v.Time : ''))) : '';
            }
            return v == null ? '' : v;
        }

        async function routeFights() {
            setStatus('rendering fights from cache...');
            const data = window.store.getJSON('fights');
            const arr = Array.isArray(data) ? data : [];
            ensureFightersCacheFromStore();
            const headers = ['ID', 'Tournament', 'Fighter 1', 'Fighter 2', 'Scheduled', 'Status', 'Winner', 'Completed At'];
            const rows = arr.map(x => {
                const f1 = x.Fighter1Name || fightersCache.byId.get(x.Fighter1ID)?.Name || String(x.Fighter1ID || '');
                const f2 = x.Fighter2Name || fightersCache.byId.get(x.Fighter2ID)?.Name || String(x.Fighter2ID || '');
                const winnerId = unwrapNullish(x, 'WinnerID');
                const winner = winnerId ? (fightersCache.byId.get(winnerId)?.Name || String(winnerId)) : '';
                const completedAt = unwrapNullish(x, 'CompletedAt');
                return [
                    String(x.ID),
                    String(x.TournamentID || ''),
                    f1,
                    f2,
                    formatTime(x.ScheduledTime),
                    x.Status || '',
                    winner,
                    formatTime(completedAt),
                ];
            });
            setView(renderTable(headers, rows));
            setStatus('');
        }

        async function routeFighters() {
            setStatus('rendering fighters from cache...');
            const data = window.store.getJSON('fighters');
            const arr = Array.isArray(data) ? data : [];
            const headers = ['ID', 'Name', 'Team', 'Class', 'Wins', 'Losses', 'Draws', 'Strength', 'Speed', 'Endurance', 'Technique'];
            const rows = arr.map(f => [
                String(f.ID), f.Name || '', f.Team || '', f.FighterClass || '',
                String(f.Wins ?? ''), String(f.Losses ?? ''), String(f.Draws ?? ''),
                String(f.Strength ?? ''), String(f.Speed ?? ''), String(f.Endurance ?? ''), String(f.Technique ?? ''),
            ]);
            setView(renderTable(headers, rows));
            setStatus('');
        }

        function setActiveNav(route) {
            $$('.nav-btn').forEach(btn => {
                if (btn.dataset.route === route) {
                    btn.classList.add('bg-gray-800');
                    btn.setAttribute('aria-current', 'page');
                } else {
                    btn.classList.remove('bg-gray-800');
                    btn.removeAttribute('aria-current');
                }
            });
        }

        async function navigate(route) {
            const r = route || ROUTES.today;
            setActiveNav(r);
            history.replaceState({ route: r }, '', `#${r}`);
            if (r === ROUTES.today) return routeToday();
            if (r === ROUTES.fights) return routeFights();
            if (r === ROUTES.fighters) return routeFighters();
        }

        // Nav events
        $$('.nav-btn').forEach(btn => btn.addEventListener('click', () => navigate(btn.dataset.route)));

        // Prefetch endpoints on load, cache responses, then navigate without new requests
        async function prefetchAll() {
            setStatus('prefetching data...');
            try {
                const [fightersRes, fightsRes, scheduleRes] = await Promise.all([
                    window.cors.fetchJson('https://spoodblort.com/api/fighters', undefined, (i, n, p) => setStatusSpinner(i, n, p?.name)),
                    window.cors.fetchJson('https://spoodblort.com/api/fights', undefined, (i, n, p) => setStatusSpinner(i, n, p?.name)),
                    window.cors.fetchJson('https://spoodblort.com/api/schedule/today', undefined, (i, n, p) => setStatusSpinner(i, n, p?.name)),
                ]);
                if (Array.isArray(fightersRes.data)) window.store.setJSON('fighters', fightersRes.data);
                if (Array.isArray(fightsRes.data)) window.store.setJSON('fights', fightsRes.data);
                if (scheduleRes?.data && typeof scheduleRes.data === 'object') window.store.setJSON('schedule_today', scheduleRes.data);
                // build in-memory fighters map from cache
                ensureFightersCacheFromStore();
            } catch (_) {
                // ignore; routes will indicate missing cache
            } finally {
                setStatus('');
            }
        }

        (async function init() {
            await prefetchAll();
            const initial = (location.hash || '#today').slice(1);
            navigate(initial);
        })();
    </script>
</body>
</html>

